{
    "collab_server" : "",
    "contents" : "library('stringr')\nlibrary('httr')\nlibrary('RCurl')\nlibrary('XML')\nlibrary('RJSONIO')\n\n# API_KEY for timezonedb.com (free).\nTZDB_API_KEY=\"VHAD5XMMMDQK\"\n# API_KEY for Google Geocoding (free).\nG_API_KEY=\"AIzaSyD8b0PZzbiYHjXe9f7LyzQLt5VgO-WSBwg\"\n\n# HELPER FUNCTIONS\ntzconv <- function(x) {\n  if (x['TIME_ZONE']==\"CDT\") {\n    x['ZONENAMES'] = \"America/Chicago\"\n  } else if (x['TIME_ZONE']==\"CST\") {\n    x['ZONENAMES'] = \"America/Chicago\"\n  } else if (x['TIME_ZONE']==\"EDT\") {\n    x['ZONENAMES'] = \"America/New_York\"\n  } else if (x['TIME_ZONE']==\"EST\") {\n    x['ZONENAMES'] = \"America/New_York\"\n  } else if (x['TIME_ZONE']==\"GMT\") {\n    x['ZONENAMES'] = \"GMT\"\n  } else if (x['TIME_ZONE']==\"HST\") {\n    x['ZONENAMES'] = \"Hawaii-Aleutian Time\"\n  } else if (x['TIME_ZONE']==\"MDT\") {\n    x['ZONENAMES'] = \"America/Denver\"\n  } else if (x['TIME_ZONE']==\"MST\") {\n    x['ZONENAMES'] = \"America/Denver\"\n  } else if (x['TIME_ZONE']==\"PDT\") {\n    x['ZONENAMES'] = \"America/Los_Angeles\"\n  } else if (x['TIME_ZONE']==\"PST\") {\n    x['ZONENAMES'] = \"America/Los_Angeles\"\n  } else if (x['TIME_ZONE']==\"SCT\") {\n    x['ZONENAMES'] = \"Seychelles Time\"\n  } else if (x['TIME_ZONE']==\"SST\") {\n    x['ZONENAMES'] = \"Samoa Standard Time\"\n  } else if (x['TIME_ZONE']==\"UTC\") {\n    x['ZONENAMES'] = \"UTC\"\n  } else {\n    x['ZONENAMES'] = timezonedb(x)\n  }\n}\n\ntimezonedb <- function(x) {\n  if (str_trim(x['LATITUDE']) == 0 && str_trim(x['LONGITUDE']) == 0) {\n    url = sprintf(\"https://maps.googleapis.com/maps/api/geocode/json?address=%s&key=%s\", str_trim(x['STATE']), G_API_KEY)\n    print(paste(\"Getting response from: \", url))\n    response <- fromJSON(url)\n    results = response$results\n    results = results[[1]]\n    \n    x['LATITUDE'] <- as.numeric(results$geometry$location['lat'])*100\n    x['LONGITUDE'] <- as.numeric(results$geometry$location['lng'])*100\n    print(sprintf(\"Received response with lat: %f and lng:%f\", x['LATITUDE'], x['LONGITUDE']))\n  }\n  url = sprintf(\"http://api.timezonedb.com/?lat=%f&lng=-%f&time=%d&key=%s\", as.numeric(x['LATITUDE'])/100, as.numeric(x['LONGITUDE'])/100, gettimestamp(x), TZDB_API_KEY)\n  print(paste(\"Getting response from timezonedb using: \", url))\n  response = getURL(url)\n  \n  if (length(response) > 0 && grep('<status>OK</status>', response[1]) == 1) {\n    response = tryCatch(xmlTreeParse(response, useInternalNodes = TRUE), error = function(e) { print(response) })\n    \n    x['ZONENAMES'] = xmlValue(xmlChildren(xmlChildren(response)$result)$zoneName)\n  } else {\n    print('Bad response from timezonedb: ' + response)\n  }\n}\n\ngettimestamp <- function(x) {\n  datetime = paste(str_split(str_trim(x['BGN_DATE']), ' ', 2)[[1]][1], str_trim(x['BGN_TIME']), sep = ' ')\n  # Just getting the UNIX timestamp, timezone doesn't really matter here.\n  timestamp = strptime(datetime, format = \"%m/%d/%Y %H%M\", tz=\"GMT\")\n  as.numeric(timestamp)\n}\n\ncreatebegintimestamps <- function(x) {\n  if (str_trim(x['BGN_DATE']) != '') {\n    datetime = paste(str_split(str_trim(x['BGN_DATE']), ' ', 2)[[1]][1], str_trim(x['BGN_TIME']), sep = ' ')\n    x['BGN_TIMESTAMP'] = strptime(datetime, format = \"%m/%d/%Y %H%M\", tz=str_trim(x['ZONENAMES']))\n  }\n}\n\ncreateendtimestamps <- function(x) {\n  if (str_trim(x['END_DATE']) != '') {\n    datetime = paste(str_split(str_trim(x['END_DATE']), ' ', 2)[[1]][1], str_trim(x['END_TIME']), sep = ' ')\n    x['END_TIMESTAMP'] = strptime(datetime, format = \"%m/%d/%Y %H%M\", tz=str_trim(x['ZONENAMES']))\n  }\n}\n# BEGIN PROCESSING\n\n# Download (if necessary) and load data.\ndir.create(file.path('.', 'data'), showWarnings = FALSE)\n\nif(!file.exists('data/repdata-data-StormData.csv.bz2')) {\n  download.file('https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2', './data/repdata-data-StormData.csv.bz2')\n}\n\nreadsizeof = 20000\nnumrecords = length(read.csv(bzfile('./data/repdata-data-StormData.csv.bz2'))[,1])\ncolumnnames = c(\"STATE__\", \"BGN_DATE\", \"BGN_TIME\", \"TIME_ZONE\", \"COUNTY\", \"COUNTYNAME\", \"STATE\", \"EVTYPE\", \"BGN_RANGE\", \"BGN_AZI\", \"BGN_LOCATI\", \"END_DATE\", \"END_TIME\", \"COUNTY_END\", \"COUNTYENDN\", \"END_RANGE\", \"END_AZI\", \"END_LOCATI\", \"LENGTH\", \"WIDTH\", \"F\", \"MAG\", \"FATALITIES\", \"INJURIES\", \"PROPDMG\", \"PROPDMGEXP\", \"CROPDMG\", \"CROPDMGEXP\", \"WFO\", \"STATEOFFIC\", \"ZONENAMES\", \"LATITUDE\", \"LONGITUDE\", \"LATITUDE_E\", \"LONGITUDE_\", \"REMARKS\", \"REFNUM\")\nclasses = c(\"numeric\", \"character\", \"character\", \"character\", \"numeric\", \"character\", \"character\", \"character\", \"numeric\", \"character\", \"character\", \"character\", \"character\", \"numeric\", \"logical\", \"numeric\", \"character\", \"character\", \"numeric\", \"numeric\", \"character\", \"numeric\", \"numeric\", \"numeric\", \"numeric\", \"character\", \"numeric\", \"character\", \"character\", \"character\", \"character\", \"numeric\", \"numeric\", \"numeric\", \"numeric\", \"character\", \"numeric\")\nprocesseddata = data.frame()\n\nfor (skip in seq(0,numrecords+readsizeof, by=readsizeof)) {\n  tmpdata = read.csv(bzfile('./data/repdata-data-StormData.csv.bz2'), skip = skip, nrows = readsizeof, colClasses = classes, col.names = columnnames)\n  zonenames = apply(tmpdata, 1, tzconv)\n  tmpdata$ZONENAMES = zonenames\n  tmpdata$BGN_TIMESTAMP = apply(tmpdata, 1, createbegintimestamps)\n  tmpdata$END_TIMESTAMP = apply(tmpdata, 1, createendtimestamps)\n  processeddata = rbind.data.frame(processeddata, tmpdata)\n  print(\"end loop\")\n}\n",
    "created" : 1460307007526.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "587727455",
    "id" : "FAD952F0",
    "lastKnownWriteTime" : 1460311982,
    "last_content_update" : 1460311982022,
    "path" : "C:/Users/Sean Smitz/R-Projects/datascience/reproducible-research/project-2/project2.R",
    "project_path" : "project2.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}